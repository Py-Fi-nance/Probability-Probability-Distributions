# -*- coding: utf-8 -*-
"""Proability and Probability dist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tUEY7v5G18u8vvCXj9OkLpYb8prVXrxZ
"""

# Function Definitions

def simple_probability(event_outcomes, total_outcomes):
    return event_outcomes / total_outcomes

def addition_rule(prob_A, prob_B, prob_A_and_B):
    return prob_A + prob_B - prob_A_and_B

def conditional_probability(prob_A_and_B, prob_B):
    return prob_A_and_B / prob_B

def bayes_theorem(prob_A, prob_B_given_A, prob_B):
    """
    Calculate the probability of A given B using Bayes' Theorem.

    :param prob_A: Prior probability of A.
    :param prob_B_given_A: Probability of B given A.
    :param prob_B: Total probability of B.
    :return: Probability of A given B.
    """
    return (prob_B_given_A * prob_A) / prob_B

# Using the Functions

# Probability of a new credit card being activated within the first month
prob_card_activation = simple_probability(500, 2000)
print("Probability of Credit Card Activation in First Month:", prob_card_activation)

# Probability of a new customer taking a loan or opening a savings account
prob_loan_or_savings = addition_rule(0.30, 0.40, 0.10)
print("Probability of Loan or Savings Account:", prob_loan_or_savings)

# Probability of loan default given it's a high-risk loan
prob_default_given_high_risk = conditional_probability(0.05, 0.20)
print("Probability of Default Given High-Risk Loan:", prob_default_given_high_risk)

# Applying Bayes' Theorem to calculate the probability of a customer defaulting on a loan given that they have a poor credit score

prob_A_given_B = bayes_theorem(0.05, 0.7, 0.1)
print("probability of a customer defaulting on a loan given that they have a poor credit score:",prob_A_given_B)

import numpy as np
from scipy.stats import binom

# Define parameters
n = 1000  # Total number of loans issued
p = 0.05  # Estimated probability of default on a loan

# Calculate probabilities of different numbers of defaults
probabilities = [binom.pmf(k, n, p) for k in range(n+1)]

# Example: Probability of more than 20 but less than 50 defaults
prob_20_to_50_defaults = sum(probabilities[21:50])

# Calculate expected number of defaults
expected_defaults = n * p

print(f"Probability of 20 to 50 defaults: {prob_20_to_50_defaults:.4f}")
print(f"Expected number of defaults: {expected_defaults}")

import numpy as np
from scipy.stats import binom

# Define parameters
n = 1000  # total number of loans in the portfolio
p = 0.02  # estimated probability of default for each loan

# Calculate binomial probabilities
# Probability of exactly k defaults out of n loans
k = 10  # number of defaults to calculate the probability for
prob_k_defaults = binom.pmf(k, n, p)

# Calculate cumulative probability
# Probability of at most k defaults
cumulative_prob = binom.cdf(k, n, p)

# Calculate expected number of defaults
expected_defaults = n * p

# Output results
print(f"Probability of exactly {k} defaults: {prob_k_defaults:.4f}")
print(f"Cumulative probability of at most {k} defaults: {cumulative_prob:.4f}")
print(f"Expected number of defaults: {expected_defaults}")

# More advanced analysis: Value at Risk (VaR) calculation for loan defaults
# For instance, calculate the 95% VaR for the number of defaults
var_95 = binom.ppf(0.95, n, p)
print(f"95% Value at Risk (number of defaults): {var_95}")

import numpy as np
from scipy.stats import binom

# Parameters
n = 1000  # Total number of transactions
p = 0.01  # Estimated base probability of a transaction being fraudulent

# Calculate the probability of observing exactly k fraudulent transactions
k = 5  # Number of fraudulent transactions to calculate the probability for
prob_k_frauds = binom.pmf(k, n, p)

# Calculate the cumulative probability
# Probability of observing at most k fraudulent transactions
cumulative_prob = binom.cdf(k, n, p)

# Output the results
print(f"Probability of exactly {k} fraudulent transactions: {prob_k_frauds:.4f}")
print(f"Cumulative probability of at most {k} fraudulent transactions: {cumulative_prob:.4f}")

# Visualize the distribution
import matplotlib.pyplot as plt

fraud_probabilities = [binom.pmf(i, n, p) for i in range(k+1)]
plt.bar(range(k+1), fraud_probabilities)
plt.title('Probability Distribution of Fraudulent Transactions')
plt.xlabel('Number of Fraudulent Transactions')
plt.ylabel('Probability')
plt.show()

import numpy as np
from scipy.stats import poisson
import matplotlib.pyplot as plt

# Parameters
lambda_ = 10  # Average number of customers arriving per hour
max_customers = 20  # Maximum number of customers to model

# Calculate Poisson probabilities
probabilities = [poisson.pmf(k, lambda_) for k in range(max_customers + 1)]

# Print probabilities of specific events
print(f"Probability of exactly 10 customers arriving in an hour: {probabilities[10]:.4f}")
print(f"Probability of more than 15 customers arriving in an hour: {1 - poisson.cdf(15, lambda_):.4f}")

# Visualization
plt.bar(range(max_customers + 1), probabilities)
plt.title('Poisson Distribution of Customer Arrivals')
plt.xlabel('Number of Customers')
plt.ylabel('Probability')
plt.xticks(range(0, max_customers + 1, 2))
plt.show()

import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt

# Credit score parameters
mean_score = 700  # mean credit score
std_dev = 50      # standard deviation of credit scores

# Calculate probabilities for different credit score ranges
low_score = 600
high_score = 800

# Probability of a credit score being lower than the low_score
prob_low = norm.cdf(low_score, mean_score, std_dev)

# Probability of a credit score being higher than the high_score
prob_high = 1 - norm.cdf(high_score, mean_score, std_dev)

# Probability of a credit score being between low_score and high_score
prob_between = norm.cdf(high_score, mean_score, std_dev) - norm.cdf(low_score, mean_score, std_dev)

# Output results
print(f"Probability of a credit score lower than {low_score}: {prob_low:.4f}")
print(f"Probability of a credit score higher than {high_score}: {prob_high:.4f}")
print(f"Probability of a credit score between {low_score} and {high_score}: {prob_between:.4f}")

# Visualization
x = np.linspace(mean_score - 3*std_dev, mean_score + 3*std_dev, 1000)
y = norm.pdf(x, mean_score, std_dev)

plt.plot(x, y)
plt.title('Normal Distribution of Credit Scores')
plt.xlabel('Credit Score')
plt.ylabel('Probability Density')
plt.fill_between(x, y, where=(x > low_score) & (x < high_score), color='skyblue', alpha=0.5)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import expon

# Parameters
lambda_inv = 20  # Mean time (in minutes) between customer service requests
max_time = 60    # Maximum time to model (in minutes)

# Calculate exponential probabilities
time_intervals = np.linspace(0, max_time, 1000)
probabilities = expon.pdf(time_intervals, scale=lambda_inv)

# Probability of the next customer service request happening within 10 minutes
prob_within_10_min = expon.cdf(10, scale=lambda_inv)

# Output result
print(f"Probability of the next customer service request happening within 10 minutes: {prob_within_10_min:.4f}")

# Visualization
plt.plot(time_intervals, probabilities)
plt.title('Exponential Distribution of Time Between Customer Service Requests')
plt.xlabel('Time (minutes)')
plt.ylabel('Probability Density')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import weibull_min

# Parameters for the Weibull distribution
shape_parameter = 1.5  # shape parameter (k)
scale_parameter = 36   # scale parameter (lambda), in months

# Time range for the analysis (e.g., up to 60 months)
time = np.linspace(0, 60, 1000)

# Calculate the probability density function (PDF) and cumulative distribution function (CDF)
pdf_values = weibull_min.pdf(time, shape_parameter, scale=scale_parameter)
cdf_values = weibull_min.cdf(time, shape_parameter, scale=scale_parameter)

# Probability of loan defaulting within 24 months
prob_default_24_months = weibull_min.cdf(24, shape_parameter, scale=scale_parameter)

# Print the probability
print(f"Probability of a loan defaulting within 24 months: {prob_default_24_months:.4f}")

# Visualization
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.plot(time, pdf_values)
plt.title('Weibull PDF: Time Until Loan Default')
plt.xlabel('Time (months)')
plt.ylabel('Probability Density')

plt.subplot(1, 2, 2)
plt.plot(time, cdf_values)
plt.title('Weibull CDF: Time Until Loan Default')
plt.xlabel('Time (months)')
plt.ylabel('Cumulative Probability')
plt.show()

